#!/opt/rh/python27/root/usr/bin/python

import subprocess
import configparser
import argparse
import os.path
import os
import sys

def list_sections(sections):
    # Tasks
    tasks = [section[section.find(' ') + 1:] for section in sections if section.startswith('task')]
    pipelines = [section[section.find(' ') + 1:] for section in sections if section.startswith('pipeline')]
    others = [section for section in sections if not section.startswith('task') and not section.startswith('pipeline')]
    print 'Tasks: '
    for task in tasks:
        print '\t' + task

    print 'Pipelines: '
    for pipeline in pipelines:
        print '\t' + pipeline

    print 'Other configurations: '
    for other in others:
        print '\t' + other

if __name__ == '__main__':
    # Parse arguments
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('-l', '--list', default=False, help='List tasks and pipelines', action='store_true')
    arg_parser.add_argument('pipeline_name', nargs='?', help='Name of pipeline or task to run')
    args = arg_parser.parse_args()

    parser = configparser.ConfigParser()
    parser._interpolation = configparser.ExtendedInterpolation()
    parser.optionxform = str # To keep it case sensitive
    if not os.path.isfile('config.ini'):
        raise Exception('Error: No configuration found')

    parser.read('config.ini')
    sections = parser.sections()

    if args.list == True:
        list_sections(sections)
        exit(0)

    pipeline_name = args.pipeline_name

    # Set configurations as environment variables
    if 'config' in parser.sections():
        for config in parser.items('config'):
            os.environ[config[0]] = config[1]

    try:
        tasks = parser.get('pipeline ' + pipeline_name, 'tasks').split()
    except configparser.NoSectionError as er:
        # If the pipeline doesn't exist run the task that matches the name
        tasks = sys.argv[1].split() 

    task_output = ''

    for task in tasks:
        task_key = 'task ' + task

        try:
            inputs = parser.get(task_key, 'input')
        except:
            print 'Error: Task {} does not exist'.format(task)
            sys.exit(0)

        if inputs == 'STDIN':
            inputs = task_output.split()
            inputs = ' '.join(inputs)

        command = parser.get(task_key, 'file')
        print 'Running {}...'.format(command)

        if parser.has_option(task_key, 'parallel') and parser.get(task_key, 'parallel') == 'true':
            inputs = inputs.split()
            commands = []
            for input in inputs:
                commands.append(command + ' ' + input)

            processes = []
            for command in commands:
                process = subprocess.Popen(command, shell=True)
                processes.append(process)

            for process in processes:
                output, _ = process.communicate()
                if type(output) is str:
                    task_output += output + '\n'
        
        elif parser.has_option(task_key, 'serial') and parser.get(task_key, 'serial') == 'true':
            inputs = inputs.split()
            commands = []
            for input in inputs:
                commands.append(command + ' ' + input)

            for command in commands:
                task_output += subprocess.check_output(command, shell=True) + '\n'

        else:
            command += ' ' + inputs
            task_output = subprocess.check_output(command, shell=True)

        print 'Task {} finished'.format(parser.get(task_key, 'file'))

    print task_output 
    
     


