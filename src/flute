#!/opt/rh/python27/root/usr/bin/python

import subprocess
import configparser
import os.path
import os
import sys

if __name__ == '__main__':
    parser = configparser.ConfigParser()
    parser._interpolation = configparser.ExtendedInterpolation()
    if not os.path.isfile('config.ini'):
        raise Exception('Error: No configuration found')

    parser.read('config.ini')
    sections = parser.sections()
    pipeline_name = sys.argv[1]

    # Set configurations as environment variables
    if 'config' in parser.sections():
        for config in parser.items('config'):
            os.environ[config[0]] = config[1]

    try:
        tasks = parser.get('pipeline ' + pipeline_name, 'tasks').split()
    except configparser.NoSectionError as er:
        # If the pipeline doesn't exist run the task that matches the name
        tasks = sys.argv[1].split() 

    task_output = ''

    for task in tasks:
        task_key = 'task ' + task

        try:
            inputs = parser.get(task_key, 'input')
        except:
            print 'Error: Task {} does not exist'.format(task)
            sys.exit(0)

        if inputs == 'STDIN':
            inputs = task_output.split()
            inputs = ' '.join(inputs)

        command = parser.get(task_key, 'file')
        print 'Running {}...'.format(command)

        if parser.has_option(task_key, 'parallel') and parser.get(task_key, 'parallel') == 'true':
            inputs = inputs.split()
            commands = []
            for input in inputs:
                commands.append(command + ' ' + input)

            processes = []
            for command in commands:
                process = subprocess.Popen(command, shell=True)
                processes.append(process)

            for process in processes:
                output, _ = process.communicate()
                if type(output) is str:
                    task_output += output + '\n'
        
        elif parser.has_option(task_key, 'serial') and parser.get(task_key, 'serial') == 'true':
            inputs = inputs.split()
            commands = []
            for input in inputs:
                commands.append(command + ' ' + input)

            for command in commands:
                task_output += subprocess.check_output(command, shell=True) + '\n'

        else:
            command += ' ' + inputs
            task_output = subprocess.check_output(command, shell=True)

        print 'Task {} finished'.format(parser.get(task_key, 'file'))

    print task_output 
    
     


